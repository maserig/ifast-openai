-- Enums
create type supplement_context as enum ('fasted','with_meal');

-- Tables
create table public.users (
  id uuid primary key default auth.uid(),
  email text not null,
  name text,
  timezone text default 'UTC',
  settings jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

create table public.fasts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.users(id) on delete cascade,
  start_at timestamptz not null,
  end_at timestamptz,
  preset_type text check (preset_type in ('16:8','24h','48h')),
  custom_duration_minutes int,
  notes text
);

create table public.supplements (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.users(id) on delete cascade,
  name text not null,
  unit text not null,
  default_amount numeric
);

create table public.supplement_logs (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.users(id) on delete cascade,
  supplement_id bigint not null references public.supplements(id) on delete cascade,
  taken_at timestamptz not null default now(),
  context supplement_context not null,
  amount numeric
);

create table public.badges (
  id bigint generated by default as identity primary key,
  code text unique not null,
  name text not null,
  description text
);

create table public.user_badges (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.users(id) on delete cascade,
  badge_id bigint not null references public.badges(id) on delete cascade,
  earned_at timestamptz not null default now(),
  unique (user_id, badge_id)
);

-- Auth helper: ensure a row exists in users after signup
create or replace function public.handle_new_user() returns trigger as $$
begin
  insert into public.users (id, email, name, timezone)
  values (new.id, new.email, new.raw_user_meta_data->>'name', coalesce(new.raw_user_meta_data->>'timezone','UTC'))
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users for each row
  execute function public.handle_new_user();